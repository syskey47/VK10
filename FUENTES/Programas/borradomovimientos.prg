OPEN DATABASE ?

SELECT 0
USE CTB_DIARIO ORDER TAG Id

SELECT 0
USE CTB_DOCUMENTOS ORDER TAG Id

REPLACE CTB_DOCUMENTOS.Vigente WITH .T. FOR YEAR(CTB_DOCUMENTOS.Fecha) = 2012
REPLACE CTB_DOCUMENTOS.Vigente WITH .T. FOR CTB_DOCUMENTOS.IdTipoDoc = 1 AND CTB_DOCUMENTOS.SaldoDocumentoCxC <> 0


SELECT DISTINCT CTB_DIARIO.IdDocumento ;
	FROM CTB_DIARIO ;
		INNER JOIN CTB_DOCUMENTOS ;
			ON CTB_DIARIO.IdDocumentoPadre = CTB_DOCUMENTOS.Id ;
	WHERE CTB_DOCUMENTOS.Vigente = .T. AND ;
		CTB_DOCUMENTOS.IdTipoDoc = 1 AND ;
		YEAR(CTB_DOCUMENTOS.Fecha) < 2012 ;
	INTO CURSOR curTEMPORAL

IF	_TALLY > 0

	SCAN 
	
		SELECT CTB_DOCUMENTOS
		LOCATE FOR CTB_DOCUMENTOS.Id = curTEMPORAL.IdDocumento
		
		IF	FOUND()
			REPLACE CTB_DOCUMENTOS.Vigente WITH .T.
		ENDIF
		
		SELECT curTEMPORAL
		
	ENDSCAN
	
ENDIF

*!* NOTA: Dejar vigentes los anticipos, para eso se debe analizar la rutina de anticipos para ver que documentos y con que
*!* saldos quedan los anticipos.
SELECT CTB_DIARIO.IdDocumento ;
	FROM CTB_DIARIO ;
		INNER JOIN CTB_DOCUMENTOS ;
			ON CTB_DIARIO.IdDocumento = CTB_DOCUMENTOS.Id ;
	WHERE INLIST(CTB_DIARIO.IdCuenta, oEMPRESA.IdAnticpoD, oEMPRESA.IdAnticpoM) ;
	INTO CURSOR curTEMPORAL
	
IF	_TALLY > 0

	SCAN 
	
		SELECT CTB_DOCUMENTOS
		LOCATE FOR CTB_DOCUMENTOS.Id = curTEMPORAL.IdDocumento
		
		IF	FOUND()
			REPLACE CTB_DOCUMENTOS.Vigente WITH .T.
		ENDIF
		
		SELECT curTEMPORAL
		
	ENDSCAN
	
ENDIF

SELECT CTB_DOCUMENTOS
DELETE FOR ! CTB_DOCUMENTOS.Vigente

SELECT CTB_DIARIO
SET RELATION TO IdDocumento INTO CTB_DOCUMENTOS

GO TOP 
DELETE FOR CTB_DIARIO.IdDocumento <> CTB_DOCUMENTOS.Id

SET RELATION TO IdDocumentoPadre INTO CTB_DOCUMENTOS

GO TOP 
DELETE FOR CTB_DIARIO.IdDocumentoPadre <> CTB_DOCUMENTOS.Id

CLOSE TABLES ALL

RETURN 
